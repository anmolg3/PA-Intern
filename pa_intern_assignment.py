# -*- coding: utf-8 -*-
"""PA Intern Assignment.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1fAWBGXNUwamR_A3VKhziEKFdkHhyuok7
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
def cost(x,y):
    temp=0
    for i in range(len(y)):
        if x<y[i]:
            temp = temp + x+y[i]
            
        else:
            temp = temp + x
            
    return temp



df = pd.read_csv('computation capacity optimization problem - Sheet1.csv')
df.columns = df.columns.str.replace(' ','_')
x_old = df['Total_provisoned_load_']
x_old = x_old.values
y = df['computation_capacity_being_used']
y = y.values
t = df['timestamp']
t = t.values

num_of_seconds = 24*60*60
arr_diff = []
arr_cost = []
arr_x = []
x = 0
while(x<max(y)):
  arr_diff.append(cost(x,y)  - x*len(y))
  arr_cost.append(cost(x,y) )
  arr_x.append(x)
  x = x+1
print(max(y))
print('cost for a day use for different values of provisional load = ',arr_cost)
plt.plot(arr_x,arr_cost)
plt.ylabel('Cost', color = 'r')
plt.xlabel('Provisional Load', color = 'g')


print(cost(400,y))

"""#Strategy to reduce cost

From the graph, clearly the cost for usage is showing an upwards trend, meaning it would be better if provisional load is set to zero and then the price of load per second is paid as when it is used. 



"""



print(cost(0,y))
print(min(y))

y_zero = np.zeros(len(y))
print(len(y), 22*4000)
print(cost(x,y_zero))

plt.plot(df['timestamp'],df['computation_capacity_being_used'])
plt.xlabel('time', color = 'r')
plt.ylabel('Load', color = 'g')

"""In the above graph, timestamps of zero loads are not given
But actually the missing timestamps mean that zero load is present.

In the code for cost, I did a trial with incorporating cost for zero loads as well, and that graph also came almost linearly increase.
So again, zero provisional load is the best way to decrease the costs. Code for that below - 
"""

arr_diff = []
arr_cost = []
arr_x = []
x = 0 
while(x<max(y)):
  arr_diff.append(cost(x,y) + x*(num_of_seconds-len(y)) - x*len(y))
  arr_cost.append(cost(x,y) + x*(num_of_seconds-len(y)) )
  arr_x.append(x)
  x = x+1
print(max(y))
print('cost for a day use for different values of provisional load = ',arr_cost)
plt.plot(arr_x,arr_cost)
plt.ylabel('Cost', color = 'r')
plt.xlabel('Provisional Load', color = 'g')

